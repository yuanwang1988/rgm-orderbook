1) I chose Java as my implementation language as Java is the language I am currently most comfortable building a substantial project quickly. I have some exposure and experience programming in C and C++ but it would take me longer to build this project using these languages. I am interested in learning / adopting other languages such as C, C++ and Scala for better performance and parallel processing characteristics.

2) In my implementation, I used a "top-heap" and a "bottom-heap" to represent bid-book (and similarly for the ask-book). The top-heap consists of orders that would be executed if we made a trade of the targeted size (the top of this heap will be the worst order that will be matched). The bottom-heap consists of orders that would not be executed if we made a trade of the targetted size (the top of this heap will be the best order that will not be matched). This is the invariant that must be maintained when a new Add Order or a new Reduce Order is received.

As a new Add Order come in, I need to insert it into the top or the bottom heap and shift orders from the top heap to the bottom heap if necessary to maintain the invariant. Let N be the number of orders in the order-book (BID or ASK) and K be the number of orders we need to move from the top-heap to the bottom-heap in order to maintain the invariants of the top-heap and bottom-heap. If an Add Order does not affect cost of buying the target size or the income of selling the target size, the time complexity of processing the Add Order is O(log(N)) because we are just adding the order to a hash-map [O(1)] and a heap [O(log(N))] for the bottom-heap. Otherwise, the time complexity is O(K*log(N)) since we are adding the order to a hashmap and heap for the top-heap and then removing K orders in the top-heap and moving them to the bottom heap (each such operation is O(log(N))). Please note that K <= target-size and K <= N.

3) The time complexity of processing a reduce order is the same. When a reduce order come in, I need to reduce the corresponding order in the bottom-heap and then, if necessary, the top-heap and shift orders from the bottom heap to the top-heap to maintain the invariant. Let N be the number of orders in the the order-book (BID or ASK) and K be the number of orders we need to move from the bottom-heap to the top-heap in order to maintain the invariants of the top-heap and bottom-heap. If an reduce order does not affect cost of buying the target size or the income of selling the target size, the time complexity of processing the reduce order is O(log(N)) because we are just removing the order from a hash-map [O(1)] and a heap [O(log(N))] for the bottom-heap. Otherwise, the time complexity is O(K*log(N)) since we are removing the order from a hashmap and heap of the top-heap and then removing K orders in the bottom-heap and moving them to the top heap (each such operation is O(log(N))). Please note that K <= target-size and K <= N.

4) If my pricer application does not run fast enough in production, I would use a profiler to analyze the performance (cpu time) of different parts of my code as I vary the input-size. If memory consumption is an issue or is causing the slow-downs by forcing memory to be swapped to disk, I can use memory consumption analysis tools to identify parts of my code consuming the most memory. After narrowing down the culprit for the poor performance, I would investigate whether I can optimize the performance/memory consumption of that part of the code.

In addition, there are a few things I know I could do to improve performance. First, I can consider having a pricer for calculating the income of selling and a separate pricer for the calculating the cost of buying since the calculations are completely independent and easily paralllelized. Alternatively, I can consider having two concurrent threads, one to compute the price to buy target-size and another thread to compute the price to sell target-size. This should improve processing speed by a constant factor of 2 (excluding the processing time required to determine whether a new add order or reduce order affects the bid-book or ask-book). Second, I can also achieve some constant factor performance improvements by reducing the data I am storing in the TradeOrder object (i.e. remove time-stamp since that is never used). I can also achieve some constant factor performance improvements by having separate implementations for the top-heap and bottom-heap. For the bottom-heap, I will not track the total order size or the total value of the orders since it is not used.

Future extensions:
There are a few areas I would like to improve upon in my implementation if this was for a real-life application and there was a business need:
1) Additional functionality: If there is a business need for dynamic target-size (as opposed to a single fixed target-size for the entire run of the pricer program), I can modify my implementation slightly to allow this additional flexibility.
2) Maintainability / Extensibility: I noted that the given pricer.in data did not have any invalid order messages. For both New Order messages and Reduce Order messages, I validated the order messages before making updates to the underlying representations of the bid-book and ask-book in order to avoid an exception interrupting an update in the middle and breaking the invariant. It is important to develop a strategy / documentation to help future developers identify code changes that could create a risk of the invariant being broken by an invalid order message.